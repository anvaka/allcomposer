/**
 * Based on the packages index (generated by index.js) finds all dependencies
 * for each package and save them into `outputFileName`
 */
var Crawler = require("crawler");
var outputFileName = 'composer_packages.json';
var query = 'https://packagist.org/packages/';
var fs = require('fs');
var semver = require('semver');
// the index file contains all found packages by `index.js`
var indexFileName = process.argv[2] || 'composer_packages_index.json';
var index = JSON.parse(fs.readFileSync(indexFileName, 'utf8'));
index = index.map(toUrl);

// How many packages did we process so far?
var total = 0;
// All packages are stored here:
var results = [];
// For some reason crawler fails with out of memory exception if you try load
// all 60k requests. Crawling it in chunks, where each chunk is 3000 packages.
// We will still do only 10 concurrent requests below. The chunk size is only
// used for queueing.
var chunkSize = 3000;

// GO!
console.log('Loaded ' + index.length + ' packages to query');

var c = new Crawler({
  maxConnections: 10,
  // This will be called for each crawled page
  callback: indexPackage,
  onDrain: saveAndExit
});

queueChunk();

return; // We are done here.

function indexPackage(error, result) {
  total += 1;
  if (total % 100 === 0) {
    console.log('Processed ' + total + ' packages');
  }
  if (total % chunkSize === 0) {
    queueChunk();
  }

  if (error) {
    console.log('!! Error: ' + error);
    return;
  }
  try {
    var body = JSON.parse(result.body);
    var versions = body && body.package && body.package.versions;
    if (!versions) {
      if (body && body.package && body.package.name) console.log('Could not find versions for ' + body.package.name);
      else console.log('No package :(');
      return;
    }
    var latest = versions['dev-master'] || findLatest(versions);
    if (latest) results.push(latest);
    else console.log('Could not find latest version for ' + body.package.name);
  } catch (e) {
    console.log('Something is wrong: ' + e);
    if (result) console.log('request: ' + JSON.stringify(result.toJSON()));
  }
}

function queueChunk() {
  if (!index.length) return;
  if (index.length < chunkSize) {
    console.log('Queueing last ' + index.length + ' packages');
    c.queue(index.splice(0, index.length));
  } else {
    console.log('Queueing next ' + chunkSize + ' packages');
    c.queue(index.splice(0, chunkSize));
  }
}

function saveAndExit() {
  fs.writeFileSync(outputFileName, JSON.stringify(results), 'utf8');
  console.log('Done!');
  console.log('Saved ' + results.length + ' packages into ' + outputFileName);
  console.log('Convert the downloaded file into graph format:');
  console.log(' node toGraph.js ./' + outputFileName);
  process.exit(0);
}

function toUrl(x) {
  return query + x + '.json';
}

function findLatest(versions) {
  var mostRecent = Object.keys(versions).sort(bySemver);
  return mostRecent[0];
}

function bySemver(x, y) {
  var xValid = semver.valid(x);
  var yValid = semver.valid(y);
  if (xValid && yValid) return semver.rcompare(x, y);
  if (xValid && !yValid) return 1;
  if (yValid && !xValid) return 1;
  return 0;
}
